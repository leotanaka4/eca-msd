\documentclass[10pt]{article}

% Pacotes extras necessários
\usepackage{amsmath}
\usepackage[lmargin=0.5in, rmargin=0.5in, tmargin=0.5in, bmargin=0.5in, includehead, includefoot]{geometry}
\usepackage{amsfonts}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{setspace}

\graphicspath{ {./images/} }

% Sets para outras partes
\setlength{\parindent}{0pt}
\setstretch{1.5}
\DeclareMathOperator{\sen}{sen}
\DeclareMathOperator{\sinc}{sinc}

%% Facilidades
%% -- Laplace
\newcommand{\Lap}[1]{\mathcal{L}\left\{#1\right\}}

%% -- Negrito em matemáticas
\newcommand{\bm}[1]{\boldsymbol{#1}}


% ------- Estilo do trabalho -------- %
\fancypagestyle{capa}{
    \fancyhf{}
    \renewcommand\headrulewidth{0pt}
    \fancyfoot[C]{
        Rio de Janeiro\\
        Maio/2023
    }
}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[L]{\thepage}
\fancyfoot{}
% ----------------------------------- %

% Dados do Grupo
\title{Modelagem de Sistemas Dinâmicos - Trabalho Nº1}
\author{
    Leonardo Soares da Costa Tanaka - DRE: 121067652
}
\date{}

\begin{document}
\maketitle
\thispagestyle{capa}
\newpage

Considerando um sistema linear invariante no tempo de u(t), saída y(t) e 
função de transferência dada por:

\begin{align*}
    H(s) = \frac{100}{16} \frac{s^2 + 16}{s^2 + 0.2s + 100}
\end{align*}

Com essa função de transferência, é possível obter os zeros e pólos do sistema utilizando a Fórmula de Bhaskara no numerador e denominador da função de transferência.
Os valores dos zeros e pólos do sistema são:
$z_1 = 4j$, $z_2 = -4j$, $p_1 = -0,1 + 9,9995j$ e $p_2 = -0,1 - 9,9995j$.

Plotando o Diagrama de Bode em Python com o seguinte código:

\begin{verbatim}
    import control as ctrl
    import matplotlib.pyplot as plt

    # 1. Definir a função de transferência do sistema
    num = [100, 0, 1600]  # numerador da função de transferência
    den = [16, 3.2, 1600]  # denominador da função de transferência
    H = ctrl.TransferFunction(num, den)

    # 2. Plotar o diagrama de Bode
    mag, phase, omega = ctrl.bode_plot(H, dB=True, Hz=True, deg=True, plot=True)
    plt.show()
\end{verbatim}

\begin{figure}[h]
    \includegraphics[scale=0.45]{bode.png}
    \centering
\end{figure}

Plotando o Diagrama de Nyquist em Python com o seguinte código:

\begin{verbatim}
    import control as ctrl
    import matplotlib.pyplot as plt

    # 1. Definir a função de transferência do sistema
    num = [100, 0, 1600]  # numerador da função de transferência
    den = [16, 3.2, 1600]  # denominador da função de transferência
    H = ctrl.TransferFunction(num, den)

    # 2. Plotar o diagrama de Nyquist
    ctrl.nyquist_plot(H, omega=None, plot=True)
    plt.show()
\end{verbatim}

\begin{figure}[h]
    \includegraphics[scale=0.45]{nyquist.png}
    \centering
\end{figure}

Escrevendo $H(jw)$:

\begin{align*}
    H(jw) = H(s)|_{s=jw} = \frac{100}{16} \frac{(jw)^2 + 16}{(jw)^2 + 0.2jw + 100} = \frac{100}{16} \frac{16 - w^2}{0.2jw + 100 - w^2}
\end{align*}

Calculando o módulo da função de trasnferência:

\begin{align*}
    |H(jw)| = \frac{100}{16} \frac{\sqrt{(16 - w^2)^2}}{\sqrt{(0.2)^2 + (100 - w^2)^2}}
\end{align*}

Calculando a fase da função de transferência:

\begin{align*}
    \angle H(jw) = arctan(0/(16 - w^2)) - arctan(0.2w/(100 - w^2))
\end{align*}

1. Foi considerado uma entrada $u(t) = cos(t) 1(t)$. Foi obtido a $y(t)$ por simulação numérica utilizando Python
e as bibliotecas NumPy, Matplotlib e Control.

\begin{verbatim}
    import numpy as np
    import control as ctrl
    import matplotlib.pyplot as plt

    # 1. Definir a função de transferência do sistema
    num = [100, 0, 1600]  # numerador da função de transferência
    den = [16, 3.2, 1600]  # denominador da função de transferência
    sys = ctrl.TransferFunction(num, den)  # criar o objeto que representa o sistema

    # 2. Definir os valores de tempo para simulação
    t = np.linspace(0, 4*np.pi, 10000)  # valores de tempo de 0 a 2*pi segundos

    # 3. Definir o sinal de entrada como o cosseno multiplicado pelo degrau unitário
    u = np.heaviside(t, 1) * np.cos(t)

    # 4. Realizar a simulação da resposta do sistema usando a função `control.forced_response()`
    t_out, yout= ctrl.forced_response(sys, T=t, U=u)

    # 5. Plotar o gráfico da resposta
    plt.plot(t_out, yout)
    plt.xlabel('t')
    plt.ylabel('y(t)')
    plt.title('Resposta ao cosseno multiplicado pelo degrau unitário')
    plt.show()
\end{verbatim}

\newpage

\begin{figure}[h]
    \includegraphics[scale=0.4]{questao1.png}
    \centering
\end{figure}

Solução analítica:

$y_{ss}(t) = |H(j)| \cdot cos(t + \angle H(j)) = \frac{100}{16} \frac{\sqrt{(16-1^2)^2}}{\sqrt{0.04 + (100 - 1^2)^2}} \cdot cos(t + arctan(0/(16 - 1^2)) - arctan(0.2/(100 - 1^2))) =$

$= \frac{100}{16} \frac{15}{\sqrt{0.04 + 99^2}} \cdot cos(t + 0 - arctan(0.2/99)) = \frac{100}{16} \frac{15}{99.000202} \cdot cos(t + 0.00202) = 0.946968 \cdot cos(t + 0.00202)$

2. Foi considerado uma entrada $u(t) = cos(4 t) 1(t)$ (frequência de zero). Foi obtido a resposta $y(t)$ por simulação numérica utilizando Python
e as bibliotecas NumPy, Matplotlib e Control.

\begin{verbatim}
    import numpy as np
    import control as ctrl
    import matplotlib.pyplot as plt

    # 1. Definir a função de transferência do sistema
    num = [100, 0, 1600]  # numerador da função de transferência
    den = [16, 3.2, 1600]  # denominador da função de transferência
    sys = ctrl.TransferFunction(num, den)  # criar o objeto que representa o sistema

    # 2. Definir os valores de tempo para simulação
    t = np.linspace(0, 4*np.pi, 10000)  # valores de tempo de 0 a 2*pi segundos

    # 3. Definir o sinal de entrada como o cosseno multiplicado pelo degrau unitário
    u = np.heaviside(t, 1) * np.cos(4*t)

    # 4. Realizar a simulação da resposta do sistema usando a função `control.forced_response()`
    t_out, yout= ctrl.forced_response(sys, T=t, U=u)

    # 5. Plotar o gráfico da resposta
    plt.plot(t_out, yout)
    plt.xlabel('t')
    plt.ylabel('y(t)')
    plt.title('Resposta ao cosseno multiplicado pelo degrau unitário')
    plt.show()
\end{verbatim}

\begin{figure}[h]
    \includegraphics[scale=0.4]{questao2.png}
    \centering
\end{figure}

Solução analítica:

$y_{ss}(t) = |H(j)| \cdot cos(4 t + \angle H(j)) = \frac{100}{16} \frac{\sqrt{(16-4^2)^2}}{\sqrt{0.04 + (100 - 4^2)^2}} \cdot cos(4 t + arctan(0/(16 - 4^2)) - arctan(0.8/(100 - 4^2))) =$

$= \frac{100}{16} \frac{0}{\sqrt{0.04 + 84^2}} \cdot cos(4 t + 0 - arctan(0.8/84)) = 0$

3. Foi considerado uma entrada $u(t) = cos(10 t) 1(t)$ (frequência de zero). Foi obtido a resposta $y(t)$ por simulação numérica utilizando Python
e as bibliotecas NumPy, Matplotlib e Control.

\begin{verbatim}
    import numpy as np
    import control as ctrl
    import matplotlib.pyplot as plt

    # 1. Definir a função de transferência do sistema
    num = [100, 0, 1600]  # numerador da função de transferência
    den = [16, 3.2, 1600]  # denominador da função de transferência
    sys = ctrl.TransferFunction(num, den)  # criar o objeto que representa o sistema

    # 2. Definir os valores de tempo para simulação
    t = np.linspace(0, 4*np.pi, 10000)  # valores de tempo de 0 a 2*pi segundos

    # 3. Definir o sinal de entrada como o cosseno multiplicado pelo degrau unitário
    u = np.heaviside(t, 1) * np.cos(10*t)

    # 4. Realizar a simulação da resposta do sistema usando a função `control.forced_response()`
    t_out, yout= ctrl.forced_response(sys, T=t, U=u)

    # 5. Plotar o gráfico da resposta
    plt.plot(t_out, yout)
    plt.xlabel('t')
    plt.ylabel('y(t)')
    plt.title('Resposta ao cosseno multiplicado pelo degrau unitário')
    plt.show()
\end{verbatim}

\begin{figure}[h]
    \includegraphics[scale=0.4]{questao3.png}
    \centering
\end{figure}

Solução analítica:

$y_{ss}(t) = |H(j)| \cdot cos(10 t + \angle H(j)) = \frac{100}{16} \frac{\sqrt{(16-10^2)^2}}{\sqrt{0.04 + (100 - 10^2)^2}} \cdot cos(10 t + arctan(0/(16 - 10^2)) - arctan(2/(100 - 10^2))) =$

$= \frac{100}{16} \frac{84}{\sqrt{0.04}} \cdot cos(10 t + \pi - arctan(2/0)) = \frac{100}{16} \frac{84}{0.2} \cdot cos(10 t + \pi - \pi/2) = 2625 \cdot cos(10 t + \pi/2)$

4. Foi considerado uma entrada $u(t) = cos(100 t) 1(t)$ (frequência de zero). Foi obtido a resposta $y(t)$ por simulação numérica utilizando Python
e as bibliotecas NumPy, Matplotlib e Control.

\begin{verbatim}
    import numpy as np
    import control as ctrl
    import matplotlib.pyplot as plt

    # 1. Definir a função de transferência do sistema
    num = [100, 0, 1600]  # numerador da função de transferência
    den = [16, 3.2, 1600]  # denominador da função de transferência
    sys = ctrl.TransferFunction(num, den)  # criar o objeto que representa o sistema

    # 2. Definir os valores de tempo para simulação
    t = np.linspace(0, np.pi/4, 10000)  # valores de tempo de 0 a 2*pi segundos

    # 3. Definir o sinal de entrada como o cosseno multiplicado pelo degrau unitário
    u = np.heaviside(t, 1) * np.cos(100*t)

    # 4. Realizar a simulação da resposta do sistema usando a função `control.forced_response()`
    t_out, yout = ctrl.forced_response(sys, T=t, U=u)

    # 5. Plotar o gráfico da resposta
    plt.plot(t_out, yout)
    plt.xlabel('t')
    plt.ylabel('y(t)')
    plt.title('Resposta ao cosseno multiplicado pelo degrau unitário')
    plt.show()
\end{verbatim}

\begin{figure}[h]
    \includegraphics[scale=0.4]{questao4.png}
    \centering
\end{figure}

Solução analítica:

$y_{ss}(t) = |H(j)| \cdot cos(100 t + \angle H(j)) = \frac{100}{16} \frac{\sqrt{(16-100^2)^2}}{\sqrt{0.04 + (100 - 100^2)^2}} \cdot cos(100 t + arctan(0/(16 - 100^2)) - arctan(20/(100 - 100^2))) =$

$= \frac{100}{16} \frac{9984}{\sqrt{0.04 + (-9900)^2}} \cdot cos(100 t + \pi - arctan(20/-9900)) = \frac{100}{16} \frac{9984}{9900} \cdot cos(100 t + \pi - 0) = 6.303 \cdot cos(100 t + \pi)$

Conclusão:

\end{document}